using System.Diagnostics;

var currFile = new StackTrace(true).GetFrame(0)?.GetFileName();
var projectDir = Path.GetFullPath(Path.Join(currFile, "../../../"));
var protoDir = Path.Join(projectDir, "src/Temporalio/Bridge/sdk-core/protos");
var apiProtoDir = Path.Join(protoDir, "api_upstream");
var testSrvProtoDir = Path.Join(protoDir, "testsrv_upstream");

// Remove entire api dir
new DirectoryInfo(Path.Join(projectDir, "src/Temporalio/Api")).Delete(true);
new DirectoryInfo(Path.Join(projectDir, "src/Temporalio/Api/Dependencies")).Create();

// Gen proto
foreach (var fi in new DirectoryInfo(apiProtoDir).GetFiles("*.proto", SearchOption.AllDirectories))
{
    if (fi.FullName.Contains("gogo"))
    {
        Protoc(
            fi.FullName,
            Path.Join(projectDir, "src/Temporalio/Api/Dependencies"),
            "",
            apiProtoDir
        );
    }
    else
    {
        Protoc(fi.FullName, Path.Join(projectDir, "src/Temporalio"), "Temporalio", apiProtoDir);
    }
}
foreach (
    var fi in new DirectoryInfo(testSrvProtoDir).GetFiles("*.proto", SearchOption.AllDirectories)
)
{
    // Ignore gogo
    if (!fi.FullName.Contains("gogo"))
    {
        Protoc(
            fi.FullName,
            Path.Join(projectDir, "src/Temporalio"),
            "Temporalio",
            apiProtoDir,
            testSrvProtoDir
        );
    }
}

// Gen RPC services
File.WriteAllText(
    Path.Join(projectDir, "src/Temporalio/Client/WorkflowService.Rpc.cs"),
    GenerateServiceRPCSource(
        Path.Join(apiProtoDir, "temporal/api/workflowservice/v1/service.proto"),
        "Temporalio.Client",
        "WorkflowService",
        "Temporalio.Api.WorkflowService.V1"
    )
);
File.WriteAllText(
    Path.Join(projectDir, "src/Temporalio/Client/OperatorService.Rpc.cs"),
    GenerateServiceRPCSource(
        Path.Join(apiProtoDir, "temporal/api/operatorservice/v1/service.proto"),
        "Temporalio.Client",
        "OperatorService",
        "Temporalio.Api.OperatorService.V1"
    )
);
File.WriteAllText(
    Path.Join(projectDir, "src/Temporalio/Client/TestService.Rpc.cs"),
    GenerateServiceRPCSource(
        Path.Join(testSrvProtoDir, "temporal/api/testservice/v1/service.proto"),
        "Temporalio.Client",
        "TestService",
        "Temporalio.Api.TestService.V1",
        new()
        {
            ["UnlockTimeSkippingWithSleep"] = "SleepRequest",
            ["GetCurrentTime"] = "Google.Protobuf.WellKnownTypes.Empty"
        },
        new()
        {
            ["SleepUntil"] = "SleepResponse",
            ["UnlockTimeSkippingWithSleep"] = "SleepResponse"
        }
    )
);

// Change Gogoproto namespace to Temporalio.Api.Dependencies.Gogoproto
foreach (
    var fi in new DirectoryInfo(Path.Join(projectDir, "src/Temporalio/Api")).GetFiles(
        "*.cs",
        SearchOption.AllDirectories
    )
)
{
    if (fi.Extension != ".cs")
    {
        continue;
    }
    string contents = File.ReadAllText(fi.FullName);
    if (fi.Name == "Gogo.cs")
    {
        // Just change the namespace field;
        File.WriteAllText(
            fi.FullName,
            contents.Replace(
                "namespace Gogoproto ",
                "namespace Temporalio.Api.Dependencies.Gogoproto "
            )
        );
    }
    else
    {
        var newContents = contents.Replace("Gogoproto.", "Temporalio.Api.Dependencies.Gogoproto.");
        if (contents != newContents)
        {
            File.WriteAllText(fi.FullName, newContents);
        }
    }
}

static void Protoc(string file, string outDir, string baseNamespace, params string[] includes)
{
    var protocArgs = new List<string> { "--csharp_out=" + outDir };
    if (baseNamespace != "")
    {
        protocArgs.Add("--csharp_opt=base_namespace=" + baseNamespace);
    }
    foreach (var include in includes)
    {
        protocArgs.Add("-I=" + include);
    }
    protocArgs.Add(file);
    Console.WriteLine("Running protoc {0}", string.Join(" ", protocArgs));
    var process = Process.Start("protoc", protocArgs);
    process.WaitForExit();
    if (process.ExitCode != 0)
    {
        throw new InvalidOperationException("protoc failed");
    }
}

static string GenerateServiceRPCSource(
    string protoFile,
    string serviceNamespace,
    string serviceClass,
    string protoNamespace,
    Dictionary<string, string>? requestOverrides = null,
    Dictionary<string, string>? responseOverrides = null
)
{
    var code = "// <auto-generated>\n//     Generated. DO NOT EDIT!\n// </auto-generated>\n";
    code += "#pragma warning disable 8669\n";
    code += "using System.Threading.Tasks;\n";
    code += $"using {protoNamespace};\n\n";
    code += $"namespace {serviceNamespace}\n{{\n";
    code += $"    public abstract partial class {serviceClass}\n    {{";
    foreach (var call in ServiceCalls(protoFile))
    {
        var req = "";
        if (requestOverrides?.TryGetValue(call, out req) != true)
        {
            req = call + "Request";
        }
        var resp = "";
        if (responseOverrides?.TryGetValue(call, out resp) != true)
        {
            resp = call + "Response";
        }
        // TODO(cretz): Copy docs from gRPC service?
        code += "\n        /// <summary>";
        code += $"\n        /// Invoke {call}.";
        code += "\n        /// </summary>";
        code += "\n        /// <param name=\"req\">Request for the call.</param>";
        code += "\n        /// <param name=\"options\">Optional RPC options.</param>";
        code += "\n        /// <returns>RPC response</returns>";
        code +=
            $"\n        public async Task<{resp}> {call}Async({req} req, RpcOptions? options = null)\n";
        code += "        {\n";
        code +=
            $"            return await InvokeRpcAsync(\"{call}\", req, {resp}.Parser, options);\n";
        code += "        }\n";
    }
    code += "    }\n}";
    return code;
}

static IEnumerable<string> ServiceCalls(string protoFile)
{
    return File.ReadAllLines(protoFile)
        .Select(v => v.TrimStart())
        .Where(v => v.StartsWith("rpc"))
        .Select(v =>
        {
            v = v.Substring(v.IndexOf("rpc") + 3).TrimStart();
            return v.Substring(0, v.IndexOfAny(new[] { ' ', '(' }));
        })
        .OrderBy(v => v);
}
