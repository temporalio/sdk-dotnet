// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: temporal/api/enums/v1/workflow.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Temporalio.Api.Enums.V1 {

  /// <summary>Holder for reflection information generated from temporal/api/enums/v1/workflow.proto</summary>
  public static partial class WorkflowReflection {

    #region Descriptor
    /// <summary>File descriptor for temporal/api/enums/v1/workflow.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static WorkflowReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiR0ZW1wb3JhbC9hcGkvZW51bXMvdjEvd29ya2Zsb3cucHJvdG8SFXRlbXBv",
            "cmFsLmFwaS5lbnVtcy52MSqPAgoVV29ya2Zsb3dJZFJldXNlUG9saWN5EigK",
            "JFdPUktGTE9XX0lEX1JFVVNFX1BPTElDWV9VTlNQRUNJRklFRBAAEiwKKFdP",
            "UktGTE9XX0lEX1JFVVNFX1BPTElDWV9BTExPV19EVVBMSUNBVEUQARI4CjRX",
            "T1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfQUxMT1dfRFVQTElDQVRFX0ZBSUxF",
            "RF9PTkxZEAISLQopV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX1JFSkVDVF9E",
            "VVBMSUNBVEUQAxI1Ci1XT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfVEVSTUlO",
            "QVRFX0lGX1JVTk5JTkcQBBoCCAEqzwEKGFdvcmtmbG93SWRDb25mbGljdFBv",
            "bGljeRIrCidXT1JLRkxPV19JRF9DT05GTElDVF9QT0xJQ1lfVU5TUEVDSUZJ",
            "RUQQABIkCiBXT1JLRkxPV19JRF9DT05GTElDVF9QT0xJQ1lfRkFJTBABEiwK",
            "KFdPUktGTE9XX0lEX0NPTkZMSUNUX1BPTElDWV9VU0VfRVhJU1RJTkcQAhIy",
            "Ci5XT1JLRkxPV19JRF9DT05GTElDVF9QT0xJQ1lfVEVSTUlOQVRFX0VYSVNU",
            "SU5HEAMqpAEKEVBhcmVudENsb3NlUG9saWN5EiMKH1BBUkVOVF9DTE9TRV9Q",
            "T0xJQ1lfVU5TUEVDSUZJRUQQABIhCh1QQVJFTlRfQ0xPU0VfUE9MSUNZX1RF",
            "Uk1JTkFURRABEh8KG1BBUkVOVF9DTE9TRV9QT0xJQ1lfQUJBTkRPThACEiYK",
            "IlBBUkVOVF9DTE9TRV9QT0xJQ1lfUkVRVUVTVF9DQU5DRUwQAyq9AQoWQ29u",
            "dGludWVBc05ld0luaXRpYXRvchIpCiVDT05USU5VRV9BU19ORVdfSU5JVElB",
            "VE9SX1VOU1BFQ0lGSUVEEAASJgoiQ09OVElOVUVfQVNfTkVXX0lOSVRJQVRP",
            "Ul9XT1JLRkxPVxABEiMKH0NPTlRJTlVFX0FTX05FV19JTklUSUFUT1JfUkVU",
            "UlkQAhIrCidDT05USU5VRV9BU19ORVdfSU5JVElBVE9SX0NST05fU0NIRURV",
            "TEUQAyqLAwoXV29ya2Zsb3dFeGVjdXRpb25TdGF0dXMSKQolV09SS0ZMT1df",
            "RVhFQ1VUSU9OX1NUQVRVU19VTlNQRUNJRklFRBAAEiUKIVdPUktGTE9XX0VY",
            "RUNVVElPTl9TVEFUVVNfUlVOTklORxABEicKI1dPUktGTE9XX0VYRUNVVElP",
            "Tl9TVEFUVVNfQ09NUExFVEVEEAISJAogV09SS0ZMT1dfRVhFQ1VUSU9OX1NU",
            "QVRVU19GQUlMRUQQAxImCiJXT1JLRkxPV19FWEVDVVRJT05fU1RBVFVTX0NB",
            "TkNFTEVEEAQSKAokV09SS0ZMT1dfRVhFQ1VUSU9OX1NUQVRVU19URVJNSU5B",
            "VEVEEAUSLgoqV09SS0ZMT1dfRVhFQ1VUSU9OX1NUQVRVU19DT05USU5VRURf",
            "QVNfTkVXEAYSJwojV09SS0ZMT1dfRVhFQ1VUSU9OX1NUQVRVU19USU1FRF9P",
            "VVQQBxIkCiBXT1JLRkxPV19FWEVDVVRJT05fU1RBVFVTX1BBVVNFRBAIKoQC",
            "ChRQZW5kaW5nQWN0aXZpdHlTdGF0ZRImCiJQRU5ESU5HX0FDVElWSVRZX1NU",
            "QVRFX1VOU1BFQ0lGSUVEEAASJAogUEVORElOR19BQ1RJVklUWV9TVEFURV9T",
            "Q0hFRFVMRUQQARIiCh5QRU5ESU5HX0FDVElWSVRZX1NUQVRFX1NUQVJURUQQ",
            "AhIrCidQRU5ESU5HX0FDVElWSVRZX1NUQVRFX0NBTkNFTF9SRVFVRVNURUQQ",
            "AxIhCh1QRU5ESU5HX0FDVElWSVRZX1NUQVRFX1BBVVNFRBAEEioKJlBFTkRJ",
            "TkdfQUNUSVZJVFlfU1RBVEVfUEFVU0VfUkVRVUVTVEVEEAUqmwEKGFBlbmRp",
            "bmdXb3JrZmxvd1Rhc2tTdGF0ZRIrCidQRU5ESU5HX1dPUktGTE9XX1RBU0tf",
            "U1RBVEVfVU5TUEVDSUZJRUQQABIpCiVQRU5ESU5HX1dPUktGTE9XX1RBU0tf",
            "U1RBVEVfU0NIRURVTEVEEAESJwojUEVORElOR19XT1JLRkxPV19UQVNLX1NU",
            "QVRFX1NUQVJURUQQAiqXAQoWSGlzdG9yeUV2ZW50RmlsdGVyVHlwZRIpCiVI",
            "SVNUT1JZX0VWRU5UX0ZJTFRFUl9UWVBFX1VOU1BFQ0lGSUVEEAASJwojSElT",
            "VE9SWV9FVkVOVF9GSUxURVJfVFlQRV9BTExfRVZFTlQQARIpCiVISVNUT1JZ",
            "X0VWRU5UX0ZJTFRFUl9UWVBFX0NMT1NFX0VWRU5UEAIqnwIKClJldHJ5U3Rh",
            "dGUSGwoXUkVUUllfU1RBVEVfVU5TUEVDSUZJRUQQABIbChdSRVRSWV9TVEFU",
            "RV9JTl9QUk9HUkVTUxABEiUKIVJFVFJZX1NUQVRFX05PTl9SRVRSWUFCTEVf",
            "RkFJTFVSRRACEhcKE1JFVFJZX1NUQVRFX1RJTUVPVVQQAxIoCiRSRVRSWV9T",
            "VEFURV9NQVhJTVVNX0FUVEVNUFRTX1JFQUNIRUQQBBIkCiBSRVRSWV9TVEFU",
            "RV9SRVRSWV9QT0xJQ1lfTk9UX1NFVBAFEiUKIVJFVFJZX1NUQVRFX0lOVEVS",
            "TkFMX1NFUlZFUl9FUlJPUhAGEiAKHFJFVFJZX1NUQVRFX0NBTkNFTF9SRVFV",
            "RVNURUQQByqwAQoLVGltZW91dFR5cGUSHAoYVElNRU9VVF9UWVBFX1VOU1BF",
            "Q0lGSUVEEAASHwobVElNRU9VVF9UWVBFX1NUQVJUX1RPX0NMT1NFEAESIgoe",
            "VElNRU9VVF9UWVBFX1NDSEVEVUxFX1RPX1NUQVJUEAISIgoeVElNRU9VVF9U",
            "WVBFX1NDSEVEVUxFX1RPX0NMT1NFEAMSGgoWVElNRU9VVF9UWVBFX0hFQVJU",
            "QkVBVBAEKn8KElZlcnNpb25pbmdCZWhhdmlvchIjCh9WRVJTSU9OSU5HX0JF",
            "SEFWSU9SX1VOU1BFQ0lGSUVEEAASHgoaVkVSU0lPTklOR19CRUhBVklPUl9Q",
            "SU5ORUQQARIkCiBWRVJTSU9OSU5HX0JFSEFWSU9SX0FVVE9fVVBHUkFERRAC",
            "KowBCh9Db250aW51ZUFzTmV3VmVyc2lvbmluZ0JlaGF2aW9yEjMKL0NPTlRJ",
            "TlVFX0FTX05FV19WRVJTSU9OSU5HX0JFSEFWSU9SX1VOU1BFQ0lGSUVEEAAS",
            "NAowQ09OVElOVUVfQVNfTkVXX1ZFUlNJT05JTkdfQkVIQVZJT1JfQVVUT19V",
            "UEdSQURFEAEqxQIKGlN1Z2dlc3RDb250aW51ZUFzTmV3UmVhc29uEi4KKlNV",
            "R0dFU1RfQ09OVElOVUVfQVNfTkVXX1JFQVNPTl9VTlNQRUNJRklFRBAAEjkK",
            "NVNVR0dFU1RfQ09OVElOVUVfQVNfTkVXX1JFQVNPTl9ISVNUT1JZX1NJWkVf",
            "VE9PX0xBUkdFEAESOgo2U1VHR0VTVF9DT05USU5VRV9BU19ORVdfUkVBU09O",
            "X1RPT19NQU5ZX0hJU1RPUllfRVZFTlRTEAISMwovU1VHR0VTVF9DT05USU5V",
            "RV9BU19ORVdfUkVBU09OX1RPT19NQU5ZX1VQREFURVMQAxJLCkdTVUdHRVNU",
            "X0NPTlRJTlVFX0FTX05FV19SRUFTT05fVEFSR0VUX1dPUktFUl9ERVBMT1lN",
            "RU5UX1ZFUlNJT05fQ0hBTkdFRBAEQoUBChhpby50ZW1wb3JhbC5hcGkuZW51",
            "bXMudjFCDVdvcmtmbG93UHJvdG9QAVohZ28udGVtcG9yYWwuaW8vYXBpL2Vu",
            "dW1zL3YxO2VudW1zqgIXVGVtcG9yYWxpby5BcGkuRW51bXMuVjHqAhpUZW1w",
            "b3JhbGlvOjpBcGk6OkVudW1zOjpWMWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Temporalio.Api.Enums.V1.WorkflowIdReusePolicy), typeof(global::Temporalio.Api.Enums.V1.WorkflowIdConflictPolicy), typeof(global::Temporalio.Api.Enums.V1.ParentClosePolicy), typeof(global::Temporalio.Api.Enums.V1.ContinueAsNewInitiator), typeof(global::Temporalio.Api.Enums.V1.WorkflowExecutionStatus), typeof(global::Temporalio.Api.Enums.V1.PendingActivityState), typeof(global::Temporalio.Api.Enums.V1.PendingWorkflowTaskState), typeof(global::Temporalio.Api.Enums.V1.HistoryEventFilterType), typeof(global::Temporalio.Api.Enums.V1.RetryState), typeof(global::Temporalio.Api.Enums.V1.TimeoutType), typeof(global::Temporalio.Api.Enums.V1.VersioningBehavior), typeof(global::Temporalio.Api.Enums.V1.ContinueAsNewVersioningBehavior), typeof(global::Temporalio.Api.Enums.V1.SuggestContinueAsNewReason), }, null, null));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// Defines whether to allow re-using a workflow id from a previously *closed* workflow.
  /// If the request is denied, the server returns a `WorkflowExecutionAlreadyStartedFailure` error.
  ///
  /// See `WorkflowIdConflictPolicy` for handling workflow id duplication with a *running* workflow.
  /// </summary>
  public enum WorkflowIdReusePolicy {
    [pbr::OriginalName("WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// Allow starting a workflow execution using the same workflow id.
    /// </summary>
    [pbr::OriginalName("WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE")] AllowDuplicate = 1,
    /// <summary>
    /// Allow starting a workflow execution using the same workflow id, only when the last
    /// execution's final state is one of [terminated, cancelled, timed out, failed].
    /// </summary>
    [pbr::OriginalName("WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY")] AllowDuplicateFailedOnly = 2,
    /// <summary>
    /// Do not permit re-use of the workflow id for this workflow. Future start workflow requests
    /// could potentially change the policy, allowing re-use of the workflow id.
    /// </summary>
    [pbr::OriginalName("WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE")] RejectDuplicate = 3,
    /// <summary>
    /// Terminate the current Workflow if one is already running; otherwise allow reusing the
    /// Workflow ID. When using this option, `WorkflowIdConflictPolicy` must be left unspecified.
    ///
    /// Deprecated. Instead, set `WorkflowIdReusePolicy` to `ALLOW_DUPLICATE` and
    /// `WorkflowIdConflictPolicy` to `TERMINATE_EXISTING`. Note that `WorkflowIdConflictPolicy`
    /// requires Temporal Server v1.24.0 or later.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [pbr::OriginalName("WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING")] TerminateIfRunning = 4,
  }

  /// <summary>
  /// Defines what to do when trying to start a workflow with the same workflow id as a *running* workflow.
  /// Note that it is *never* valid to have two actively running instances of the same workflow id.
  ///
  /// See `WorkflowIdReusePolicy` for handling workflow id duplication with a *closed* workflow.
  /// </summary>
  public enum WorkflowIdConflictPolicy {
    [pbr::OriginalName("WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// Don't start a new workflow; instead return `WorkflowExecutionAlreadyStartedFailure`.
    /// </summary>
    [pbr::OriginalName("WORKFLOW_ID_CONFLICT_POLICY_FAIL")] Fail = 1,
    /// <summary>
    /// Don't start a new workflow; instead return a workflow handle for the running workflow.
    /// </summary>
    [pbr::OriginalName("WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING")] UseExisting = 2,
    /// <summary>
    /// Terminate the running workflow before starting a new one.
    /// </summary>
    [pbr::OriginalName("WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING")] TerminateExisting = 3,
  }

  /// <summary>
  /// Defines how child workflows will react to their parent completing
  /// </summary>
  public enum ParentClosePolicy {
    [pbr::OriginalName("PARENT_CLOSE_POLICY_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// The child workflow will also terminate
    /// </summary>
    [pbr::OriginalName("PARENT_CLOSE_POLICY_TERMINATE")] Terminate = 1,
    /// <summary>
    /// The child workflow will do nothing
    /// </summary>
    [pbr::OriginalName("PARENT_CLOSE_POLICY_ABANDON")] Abandon = 2,
    /// <summary>
    /// Cancellation will be requested of the child workflow
    /// </summary>
    [pbr::OriginalName("PARENT_CLOSE_POLICY_REQUEST_CANCEL")] RequestCancel = 3,
  }

  public enum ContinueAsNewInitiator {
    [pbr::OriginalName("CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// The workflow itself requested to continue as new
    /// </summary>
    [pbr::OriginalName("CONTINUE_AS_NEW_INITIATOR_WORKFLOW")] Workflow = 1,
    /// <summary>
    /// The workflow continued as new because it is retrying
    /// </summary>
    [pbr::OriginalName("CONTINUE_AS_NEW_INITIATOR_RETRY")] Retry = 2,
    /// <summary>
    /// The workflow continued as new because cron has triggered a new execution
    /// </summary>
    [pbr::OriginalName("CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE")] CronSchedule = 3,
  }

  /// <summary>
  /// (-- api-linter: core::0216::synonyms=disabled
  ///     aip.dev/not-precedent: There is WorkflowExecutionState already in another package. --)
  /// </summary>
  public enum WorkflowExecutionStatus {
    [pbr::OriginalName("WORKFLOW_EXECUTION_STATUS_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// Value 1 is hardcoded in SQL persistence.
    /// </summary>
    [pbr::OriginalName("WORKFLOW_EXECUTION_STATUS_RUNNING")] Running = 1,
    [pbr::OriginalName("WORKFLOW_EXECUTION_STATUS_COMPLETED")] Completed = 2,
    [pbr::OriginalName("WORKFLOW_EXECUTION_STATUS_FAILED")] Failed = 3,
    [pbr::OriginalName("WORKFLOW_EXECUTION_STATUS_CANCELED")] Canceled = 4,
    [pbr::OriginalName("WORKFLOW_EXECUTION_STATUS_TERMINATED")] Terminated = 5,
    [pbr::OriginalName("WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW")] ContinuedAsNew = 6,
    [pbr::OriginalName("WORKFLOW_EXECUTION_STATUS_TIMED_OUT")] TimedOut = 7,
    [pbr::OriginalName("WORKFLOW_EXECUTION_STATUS_PAUSED")] Paused = 8,
  }

  public enum PendingActivityState {
    [pbr::OriginalName("PENDING_ACTIVITY_STATE_UNSPECIFIED")] Unspecified = 0,
    [pbr::OriginalName("PENDING_ACTIVITY_STATE_SCHEDULED")] Scheduled = 1,
    [pbr::OriginalName("PENDING_ACTIVITY_STATE_STARTED")] Started = 2,
    [pbr::OriginalName("PENDING_ACTIVITY_STATE_CANCEL_REQUESTED")] CancelRequested = 3,
    /// <summary>
    /// PAUSED means activity is paused on the server, and is not running in the worker
    /// </summary>
    [pbr::OriginalName("PENDING_ACTIVITY_STATE_PAUSED")] Paused = 4,
    /// <summary>
    /// PAUSE_REQUESTED means activity is currently running on the worker, but paused on the server
    /// </summary>
    [pbr::OriginalName("PENDING_ACTIVITY_STATE_PAUSE_REQUESTED")] PauseRequested = 5,
  }

  public enum PendingWorkflowTaskState {
    [pbr::OriginalName("PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED")] Unspecified = 0,
    [pbr::OriginalName("PENDING_WORKFLOW_TASK_STATE_SCHEDULED")] Scheduled = 1,
    [pbr::OriginalName("PENDING_WORKFLOW_TASK_STATE_STARTED")] Started = 2,
  }

  public enum HistoryEventFilterType {
    [pbr::OriginalName("HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED")] Unspecified = 0,
    [pbr::OriginalName("HISTORY_EVENT_FILTER_TYPE_ALL_EVENT")] AllEvent = 1,
    [pbr::OriginalName("HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT")] CloseEvent = 2,
  }

  public enum RetryState {
    [pbr::OriginalName("RETRY_STATE_UNSPECIFIED")] Unspecified = 0,
    [pbr::OriginalName("RETRY_STATE_IN_PROGRESS")] InProgress = 1,
    [pbr::OriginalName("RETRY_STATE_NON_RETRYABLE_FAILURE")] NonRetryableFailure = 2,
    [pbr::OriginalName("RETRY_STATE_TIMEOUT")] Timeout = 3,
    [pbr::OriginalName("RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED")] MaximumAttemptsReached = 4,
    [pbr::OriginalName("RETRY_STATE_RETRY_POLICY_NOT_SET")] RetryPolicyNotSet = 5,
    [pbr::OriginalName("RETRY_STATE_INTERNAL_SERVER_ERROR")] InternalServerError = 6,
    [pbr::OriginalName("RETRY_STATE_CANCEL_REQUESTED")] CancelRequested = 7,
  }

  public enum TimeoutType {
    [pbr::OriginalName("TIMEOUT_TYPE_UNSPECIFIED")] Unspecified = 0,
    [pbr::OriginalName("TIMEOUT_TYPE_START_TO_CLOSE")] StartToClose = 1,
    [pbr::OriginalName("TIMEOUT_TYPE_SCHEDULE_TO_START")] ScheduleToStart = 2,
    [pbr::OriginalName("TIMEOUT_TYPE_SCHEDULE_TO_CLOSE")] ScheduleToClose = 3,
    [pbr::OriginalName("TIMEOUT_TYPE_HEARTBEAT")] Heartbeat = 4,
  }

  /// <summary>
  /// Versioning Behavior specifies if and how a workflow execution moves between Worker Deployment
  /// Versions. The Versioning Behavior of a workflow execution is typically specified by the worker
  /// who completes the first task of the execution, but is also overridable manually for new and
  /// existing workflows (see VersioningOverride).
  /// Experimental. Worker Deployments are experimental and might significantly change in the future.
  /// </summary>
  public enum VersioningBehavior {
    /// <summary>
    /// Workflow execution does not have a Versioning Behavior and is called Unversioned. This is the
    /// legacy behavior. An Unversioned workflow's task can go to any Unversioned worker (see
    /// `WorkerVersioningMode`.)
    /// User needs to use Patching to keep the new code compatible with prior versions when dealing
    /// with Unversioned workflows.
    /// </summary>
    [pbr::OriginalName("VERSIONING_BEHAVIOR_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// Workflow will start on its Target Version and then will be pinned to that same Deployment
    /// Version until completion (the Version that this Workflow is pinned to is specified in
    /// `versioning_info.version` and is the Pinned Version of the Workflow).
    ///
    /// The workflow's Target Version is the Current Version of its Task Queue, or, if the
    /// Task Queue has a Ramping Version with non-zero Ramp Percentage `P`, the workflow's Target
    /// Version has a P% chance of being the Ramping Version. Whether a workflow falls into the
    /// Ramping group depends on its Workflow ID and and the Ramp Percentage.
    ///
    /// This behavior eliminates most of compatibility concerns users face when changing their code.
    /// Patching is not needed when pinned workflows code change.
    /// Can be overridden explicitly via `UpdateWorkflowExecutionOptions` API to move the
    /// execution to another Deployment Version.
    /// Activities of `PINNED` workflows are sent to the same Deployment Version. Exception to this
    /// would be when the activity Task Queue workers are not present in the workflow's Deployment
    /// Version, in which case the activity will be sent to the Current Deployment Version of its own
    /// task queue.
    /// </summary>
    [pbr::OriginalName("VERSIONING_BEHAVIOR_PINNED")] Pinned = 1,
    /// <summary>
    /// Workflow will automatically move to its Target Version when the next workflow task is dispatched.
    ///
    /// The workflow's Target Version is the Current Version of its Task Queue, or, if the
    /// Task Queue has a Ramping Version with non-zero Ramp Percentage `P`, the workflow's Target
    /// Version has a P% chance of being the Ramping Version. Whether a workflow falls into the
    /// Ramping group depends on its Workflow ID and and the Ramp Percentage.
    ///
    /// AutoUpgrade behavior is suitable for long-running workflows as it allows them to move to the
    /// latest Deployment Version, but the user still needs to use Patching to keep the new code
    /// compatible with prior versions for changed workflow types.
    /// Activities of `AUTO_UPGRADE` workflows are sent to the Deployment Version of the workflow
    /// execution (as specified in versioning_info.version based on the last completed
    /// workflow task). Exception to this would be when the activity Task Queue workers are not
    /// present in the workflow's Deployment Version, in which case, the activity will be sent to a
    /// different Deployment Version according to the Current or Ramping Deployment Version of its own
    /// Task Queue.
    /// Workflows stuck on a backlogged activity will still auto-upgrade if their Target Version
    /// changes, without having to wait for the backlogged activity to complete on the old Version.
    /// </summary>
    [pbr::OriginalName("VERSIONING_BEHAVIOR_AUTO_UPGRADE")] AutoUpgrade = 2,
  }

  /// <summary>
  /// Experimental. Defines the versioning behavior to be used by the first task of a new workflow run in a continue-as-new chain.
  /// </summary>
  public enum ContinueAsNewVersioningBehavior {
    [pbr::OriginalName("CONTINUE_AS_NEW_VERSIONING_BEHAVIOR_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// Start the new run with AutoUpgrade behavior. Use the Target Version of the workflow's task queue at
    /// start-time, as AutoUpgrade workflows do. After the first workflow task completes, use whatever
    /// Versioning Behavior the workflow is annotated with in the workflow code.
    ///
    /// Note that if the previous workflow had a Pinned override, that override will be inherited by the
    /// new workflow run regardless of the ContinueAsNewVersioningBehavior specified in the continue-as-new
    /// command. If a Pinned override is inherited by the new run, and the new run starts with AutoUpgrade
    /// behavior, the base version of the new run will be the Target Version as described above, but the
    /// effective version will be whatever is specified by the Versioning Override until the override is removed.
    /// </summary>
    [pbr::OriginalName("CONTINUE_AS_NEW_VERSIONING_BEHAVIOR_AUTO_UPGRADE")] AutoUpgrade = 1,
  }

  /// <summary>
  /// SuggestContinueAsNewReason specifies why SuggestContinueAsNew is true.
  /// </summary>
  public enum SuggestContinueAsNewReason {
    [pbr::OriginalName("SUGGEST_CONTINUE_AS_NEW_REASON_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// Workflow History size is getting too large.
    /// </summary>
    [pbr::OriginalName("SUGGEST_CONTINUE_AS_NEW_REASON_HISTORY_SIZE_TOO_LARGE")] HistorySizeTooLarge = 1,
    /// <summary>
    /// Workflow History event count is getting too large.
    /// </summary>
    [pbr::OriginalName("SUGGEST_CONTINUE_AS_NEW_REASON_TOO_MANY_HISTORY_EVENTS")] TooManyHistoryEvents = 2,
    /// <summary>
    /// Workflow's count of completed plus in-flight updates is too large.
    /// </summary>
    [pbr::OriginalName("SUGGEST_CONTINUE_AS_NEW_REASON_TOO_MANY_UPDATES")] TooManyUpdates = 3,
    /// <summary>
    /// Workflow's Target Worker Deployment Version is different from its
    /// Current Version and the workflow is versioned.
    /// </summary>
    [pbr::OriginalName("SUGGEST_CONTINUE_AS_NEW_REASON_TARGET_WORKER_DEPLOYMENT_VERSION_CHANGED")] TargetWorkerDeploymentVersionChanged = 4,
  }

  #endregion

}

#endregion Designer generated code
