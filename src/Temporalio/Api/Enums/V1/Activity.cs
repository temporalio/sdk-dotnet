// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: temporal/api/enums/v1/activity.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Temporalio.Api.Enums.V1 {

  /// <summary>Holder for reflection information generated from temporal/api/enums/v1/activity.proto</summary>
  public static partial class ActivityReflection {

    #region Descriptor
    /// <summary>File descriptor for temporal/api/enums/v1/activity.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ActivityReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiR0ZW1wb3JhbC9hcGkvZW51bXMvdjEvYWN0aXZpdHkucHJvdG8SFXRlbXBv",
            "cmFsLmFwaS5lbnVtcy52MSq1AgoXQWN0aXZpdHlFeGVjdXRpb25TdGF0dXMS",
            "KQolQUNUSVZJVFlfRVhFQ1VUSU9OX1NUQVRVU19VTlNQRUNJRklFRBAAEiUK",
            "IUFDVElWSVRZX0VYRUNVVElPTl9TVEFUVVNfUlVOTklORxABEicKI0FDVElW",
            "SVRZX0VYRUNVVElPTl9TVEFUVVNfQ09NUExFVEVEEAISJAogQUNUSVZJVFlf",
            "RVhFQ1VUSU9OX1NUQVRVU19GQUlMRUQQAxImCiJBQ1RJVklUWV9FWEVDVVRJ",
            "T05fU1RBVFVTX0NBTkNFTEVEEAQSKAokQUNUSVZJVFlfRVhFQ1VUSU9OX1NU",
            "QVRVU19URVJNSU5BVEVEEAUSJwojQUNUSVZJVFlfRVhFQ1VUSU9OX1NUQVRV",
            "U19USU1FRF9PVVQQBirYAQoVQWN0aXZpdHlJZFJldXNlUG9saWN5EigKJEFD",
            "VElWSVRZX0lEX1JFVVNFX1BPTElDWV9VTlNQRUNJRklFRBAAEiwKKEFDVElW",
            "SVRZX0lEX1JFVVNFX1BPTElDWV9BTExPV19EVVBMSUNBVEUQARI4CjRBQ1RJ",
            "VklUWV9JRF9SRVVTRV9QT0xJQ1lfQUxMT1dfRFVQTElDQVRFX0ZBSUxFRF9P",
            "TkxZEAISLQopQUNUSVZJVFlfSURfUkVVU0VfUE9MSUNZX1JFSkVDVF9EVVBM",
            "SUNBVEUQAyqbAQoYQWN0aXZpdHlJZENvbmZsaWN0UG9saWN5EisKJ0FDVElW",
            "SVRZX0lEX0NPTkZMSUNUX1BPTElDWV9VTlNQRUNJRklFRBAAEiQKIEFDVElW",
            "SVRZX0lEX0NPTkZMSUNUX1BPTElDWV9GQUlMEAESLAooQUNUSVZJVFlfSURf",
            "Q09ORkxJQ1RfUE9MSUNZX1VTRV9FWElTVElORxACQoUBChhpby50ZW1wb3Jh",
            "bC5hcGkuZW51bXMudjFCDUFjdGl2aXR5UHJvdG9QAVohZ28udGVtcG9yYWwu",
            "aW8vYXBpL2VudW1zL3YxO2VudW1zqgIXVGVtcG9yYWxpby5BcGkuRW51bXMu",
            "VjHqAhpUZW1wb3JhbGlvOjpBcGk6OkVudW1zOjpWMWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Temporalio.Api.Enums.V1.ActivityExecutionStatus), typeof(global::Temporalio.Api.Enums.V1.ActivityIdReusePolicy), typeof(global::Temporalio.Api.Enums.V1.ActivityIdConflictPolicy), }, null, null));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// Status of a standalone activity.
  /// The status is updated once, when the activity is originally scheduled, and again when the activity reaches a terminal
  /// status.
  /// (-- api-linter: core::0216::synonyms=disabled
  ///     aip.dev/not-precedent: Named consistently with WorkflowExecutionStatus. --)
  /// </summary>
  public enum ActivityExecutionStatus {
    [pbr::OriginalName("ACTIVITY_EXECUTION_STATUS_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// The activity has not reached a terminal status. See PendingActivityState for the run state
    /// (SCHEDULED, STARTED, or CANCEL_REQUESTED).
    /// </summary>
    [pbr::OriginalName("ACTIVITY_EXECUTION_STATUS_RUNNING")] Running = 1,
    /// <summary>
    /// The activity completed successfully. An activity can complete even after cancellation is
    /// requested if the worker calls RespondActivityTaskCompleted before acknowledging cancellation.
    /// </summary>
    [pbr::OriginalName("ACTIVITY_EXECUTION_STATUS_COMPLETED")] Completed = 2,
    /// <summary>
    /// The activity failed. Causes:
    /// - Worker returned a non-retryable failure
    /// - RetryPolicy.maximum_attempts exhausted
    /// - Attempt failed after cancellation was requested (retries blocked)
    /// </summary>
    [pbr::OriginalName("ACTIVITY_EXECUTION_STATUS_FAILED")] Failed = 3,
    /// <summary>
    /// The activity was canceled. Reached when:
    /// - Cancellation requested while SCHEDULED (immediate), or
    /// - Cancellation requested while STARTED and worker called RespondActivityTaskCanceled.
    ///
    /// Workers discover cancellation requests via heartbeat responses (cancel_requested=true).
    /// Activities that do not heartbeat will not learn of cancellation and may complete, fail, or
    /// time out normally. CANCELED requires explicit worker acknowledgment or immediate cancellation
    /// of a SCHEDULED activity.
    /// </summary>
    [pbr::OriginalName("ACTIVITY_EXECUTION_STATUS_CANCELED")] Canceled = 4,
    /// <summary>
    /// The activity was terminated. Immediate; does not wait for worker acknowledgment.
    /// </summary>
    [pbr::OriginalName("ACTIVITY_EXECUTION_STATUS_TERMINATED")] Terminated = 5,
    /// <summary>
    /// The activity timed out. See TimeoutType for the specific timeout.
    /// - SCHEDULE_TO_START and SCHEDULE_TO_CLOSE timeouts always result in TIMED_OUT.
    /// - START_TO_CLOSE and HEARTBEAT may retry if RetryPolicy permits; TIMED_OUT is
    ///   reached when retry is blocked (RetryPolicy.maximum_attempts exhausted,
    ///   SCHEDULE_TO_CLOSE would be exceeded, or cancellation has been requested).
    /// </summary>
    [pbr::OriginalName("ACTIVITY_EXECUTION_STATUS_TIMED_OUT")] TimedOut = 6,
  }

  /// <summary>
  /// Defines whether to allow re-using an activity ID from a previously *closed* activity.
  /// If the request is denied, the server returns an `ActivityExecutionAlreadyStarted` error.
  ///
  /// See `ActivityIdConflictPolicy` for handling ID duplication with a *running* activity.
  /// </summary>
  public enum ActivityIdReusePolicy {
    [pbr::OriginalName("ACTIVITY_ID_REUSE_POLICY_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// Always allow starting an activity using the same activity ID.
    /// </summary>
    [pbr::OriginalName("ACTIVITY_ID_REUSE_POLICY_ALLOW_DUPLICATE")] AllowDuplicate = 1,
    /// <summary>
    /// Allow starting an activity using the same ID only when the last activity's final state is one
    /// of {failed, canceled, terminated, timed out}.
    /// </summary>
    [pbr::OriginalName("ACTIVITY_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY")] AllowDuplicateFailedOnly = 2,
    /// <summary>
    /// Do not permit re-use of the ID for this activity. Future start requests could potentially change the policy,
    /// allowing re-use of the ID.
    /// </summary>
    [pbr::OriginalName("ACTIVITY_ID_REUSE_POLICY_REJECT_DUPLICATE")] RejectDuplicate = 3,
  }

  /// <summary>
  /// Defines what to do when trying to start an activity with the same ID as a *running* activity.
  /// Note that it is *never* valid to have two running instances of the same activity ID.
  ///
  /// See `ActivityIdReusePolicy` for handling activity ID duplication with a *closed* activity.
  /// </summary>
  public enum ActivityIdConflictPolicy {
    [pbr::OriginalName("ACTIVITY_ID_CONFLICT_POLICY_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// Don't start a new activity; instead return `ActivityExecutionAlreadyStarted` error.
    /// </summary>
    [pbr::OriginalName("ACTIVITY_ID_CONFLICT_POLICY_FAIL")] Fail = 1,
    /// <summary>
    /// Don't start a new activity; instead return a handle for the running activity.
    /// </summary>
    [pbr::OriginalName("ACTIVITY_ID_CONFLICT_POLICY_USE_EXISTING")] UseExisting = 2,
  }

  #endregion

}

#endregion Designer generated code
