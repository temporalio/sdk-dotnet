// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: temporal/api/enums/v1/schedule.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Temporalio.Api.Enums.V1 {

  /// <summary>Holder for reflection information generated from temporal/api/enums/v1/schedule.proto</summary>
  public static partial class ScheduleReflection {

    #region Descriptor
    /// <summary>File descriptor for temporal/api/enums/v1/schedule.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ScheduleReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiR0ZW1wb3JhbC9hcGkvZW51bXMvdjEvc2NoZWR1bGUucHJvdG8SFXRlbXBv",
            "cmFsLmFwaS5lbnVtcy52MSqwAgoVU2NoZWR1bGVPdmVybGFwUG9saWN5EicK",
            "I1NDSEVEVUxFX09WRVJMQVBfUE9MSUNZX1VOU1BFQ0lGSUVEEAASIAocU0NI",
            "RURVTEVfT1ZFUkxBUF9QT0xJQ1lfU0tJUBABEiYKIlNDSEVEVUxFX09WRVJM",
            "QVBfUE9MSUNZX0JVRkZFUl9PTkUQAhImCiJTQ0hFRFVMRV9PVkVSTEFQX1BP",
            "TElDWV9CVUZGRVJfQUxMEAMSKAokU0NIRURVTEVfT1ZFUkxBUF9QT0xJQ1lf",
            "Q0FOQ0VMX09USEVSEAQSKwonU0NIRURVTEVfT1ZFUkxBUF9QT0xJQ1lfVEVS",
            "TUlOQVRFX09USEVSEAUSJQohU0NIRURVTEVfT1ZFUkxBUF9QT0xJQ1lfQUxM",
            "T1dfQUxMEAZChQEKGGlvLnRlbXBvcmFsLmFwaS5lbnVtcy52MUINU2NoZWR1",
            "bGVQcm90b1ABWiFnby50ZW1wb3JhbC5pby9hcGkvZW51bXMvdjE7ZW51bXOq",
            "AhdUZW1wb3JhbGlvLkFwaS5FbnVtcy5WMeoCGlRlbXBvcmFsaW86OkFwaTo6",
            "RW51bXM6OlYxYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Temporalio.Api.Enums.V1.ScheduleOverlapPolicy), }, null, null));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// ScheduleOverlapPolicy controls what happens when a workflow would be started
  /// by a schedule, and is already running.
  /// </summary>
  public enum ScheduleOverlapPolicy {
    [pbr::OriginalName("SCHEDULE_OVERLAP_POLICY_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// SCHEDULE_OVERLAP_POLICY_SKIP (default) means don't start anything. When the
    /// workflow completes, the next scheduled event after that time will be considered.
    /// </summary>
    [pbr::OriginalName("SCHEDULE_OVERLAP_POLICY_SKIP")] Skip = 1,
    /// <summary>
    /// SCHEDULE_OVERLAP_POLICY_BUFFER_ONE means start the workflow again soon as the
    /// current one completes, but only buffer one start in this way. If another start is
    /// supposed to happen when the workflow is running, and one is already buffered, then
    /// only the first one will be started after the running workflow finishes.
    /// </summary>
    [pbr::OriginalName("SCHEDULE_OVERLAP_POLICY_BUFFER_ONE")] BufferOne = 2,
    /// <summary>
    /// SCHEDULE_OVERLAP_POLICY_BUFFER_ALL means buffer up any number of starts to all
    /// happen sequentially, immediately after the running workflow completes.
    /// </summary>
    [pbr::OriginalName("SCHEDULE_OVERLAP_POLICY_BUFFER_ALL")] BufferAll = 3,
    /// <summary>
    /// SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER means that if there is another workflow
    /// running, cancel it, and start the new one after the old one completes cancellation.
    /// </summary>
    [pbr::OriginalName("SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER")] CancelOther = 4,
    /// <summary>
    /// SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER means that if there is another workflow
    /// running, terminate it and start the new one immediately.
    /// </summary>
    [pbr::OriginalName("SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER")] TerminateOther = 5,
    /// <summary>
    /// SCHEDULE_OVERLAP_POLICY_ALLOW_ALL means start any number of concurrent workflows.
    /// Note that with this policy, last completion result and last failure will not be
    /// available since workflows are not sequential.
    /// </summary>
    [pbr::OriginalName("SCHEDULE_OVERLAP_POLICY_ALLOW_ALL")] AllowAll = 6,
  }

  #endregion

}

#endregion Designer generated code
